---
title: Analyze error details
metaDescription: Learn how to manage a high number of errors in your app.   
---

import apmErrorsAttributes from 'images/apm_screenshot-crop_errors-details.webp'

import apmLogs from 'images/apm_screenshot-crop_errors-logs.webp'

import apmLogsZoom from 'images/apm_screenshot-crop_errors-logs-zoomed.webp'

import apmStackTraces from 'images/apm_screenshot-crop_errors-stack-traces.webp'

Although we've identified a service that is closest to the problem, we haven't yet dug into the data available to you. From the **Errors** summary page, you've already clicked the error that is the most likely to lead you to the source of your outage. This page gives you one entry point into analyzing your app's health so you can view how your system is performing from the vantage point of error occurrences. 

Once you click through your desired error, New Relic takes you to a new page that displays attributes, logs, and traces about the error, giving you one entry point into your entire system architecture. This part of the tutorial guides you through two recommended avenues for analyzing an error. 

## Objectives [#objectives]

This doc builds off the problem scoped from the [Scope the problem](/docs/tutorial-errors/scope-the-problem) doc of this tutorial series. In this doc, you will:

* Analyze your data with logs and traces 
* Identify what changed that caused a problem to occur  

## Examine errors with logs [#logs]

It's likely some error pages will lack full details when you're initially conducting error analysis. This can be because you've disabled distributed tracing, or maybe the nature of the error -- like a 500 error -- excludes stack trace details. At installation, your agent is able to collect some logging attributes about your application, but not all of them. Our biggest recommendations for APM is to set up your log forwarder to forward full log details to New Relic. This expedites the error analysis process.  

Looking at our example, our log forwarder has sent full log details to New Relic. This allows us to read denser descriptions about the nature of our error:

<SideBySide>

    <Side>

    <img
        title="Overview errors affecting your services"
        alt="A screenshot showing an app with many errors"
        src={apmLogs}
    />

    </Side>

<Side>

    <img
        title="Overview errors affecting your services"
        alt="A screenshot showing an app with many errors"
        src={apmLogsZoom}
    />    

</Side>
</SideBySide>

According to your logs, your problem is:

* A timeout error: `error.error.code: ETIMEDOUT`
* Related to your customer API: `error.endpoint: customers-api-internal`
* Agnostic to the kind of request sent to the customer API: `error.request: /api/customers/search/Kirlin/-/`

In other words, all calls to the customer API are timing out and, as a result, upstream requests from `api-gateway` are failing. 

At this point you've scoped out how a problem is affecting your customers, you know when the problem first occurred, and have found the source of your outage. Depending on your role, you can triage the error to the responsible team or begin fixing the problem in your system yourself. 

## Locate errors with stack traces [#traces]

When you run your code, New Relic captures exceptions and organizes them into a waterfall view called stack traces. Depending on the language used, these stack traces can provide detailed messages and additional context about failure points.  

    <img
        title="Overview errors affecting your services"
        alt="A screenshot showing an app with many errors"
        src={apmStackTraces}
    />    

Let's say you have hundreds of lines of code and something's been mistyped somewhere. Reading that code from top to bottom wastes time and introduces more human error in the troubleshooting process. Stack traces help you hone in on where the problem likely exists. For example:

* If something in line 347 references a function in line 100, your stack traces will call that part of your code out. Maybe there's a typo, or maybe you need to check the logic of that section of code.
* Stack traces give you identifying information that help you prioritize different parts of your code. Working off the above screenshot, `threading.py` could belong to a critical part of your application whereas `app.py` may belong to a less critical part of your app. In that case, you know to find the sections of your code that correspond to `threading.py`. 

## Triage your errors [#triage]



<UserJourneyControls
    nextStep={{path: "/docs/tutorial-error/analyze-your-errors", title: "Next step", body: "Direct cause versus root cause"}}
    previousStep={{path: "/docs/tutorial-errors/scope-the-problem", title: "Previous step", body: "Scope out the problem space"}}
/>