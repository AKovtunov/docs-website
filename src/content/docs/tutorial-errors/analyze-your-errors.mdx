---
title: Analyze error details
metaDescription: Learn how to manage a high number of errors in your app.   
---

import apmErrorsAttributes from 'images/apm_screenshot-crop_errors-details.webp'

import apmLogs from 'images/apm_screenshot-crop_errors-logs.webp'

import apmLogsZoom from 'images/apm_screenshot-crop_errors-logs-zoomed.webp'

import apmStackTraces from 'images/apm_screenshot-crop_errors-stack-traces.webp'

import apmTriageError from 'images/apm_screenshot-crop_errors-triage.webp'

Once you've chosen your error group, New Relic takes you to a new page that displays attributes, logs, and traces about the error. This part of the tutorial guides you through two recommended avenues for analyzing an error, your logs and stack traces. 

## Objectives [#objectives]

This doc builds off the problem scoped from the [Scope the problem](/docs/tutorial-errors/scope-the-problem) doc of this tutorial series. In this doc, you will:

* Find the error code associated with a failing API with logs
* Use stack traces to identify faulty code logic or mistype code  

## PENDING [#analyze]

The errors summary tells the story behind your error groups. Depending on how you've configured New Relic, each service might display different kinds of information about an error. For example, disabling distributed tracing limits trace details about external services. Neglecting to set up a log forwarder can similarly limit what attributes your logs show you. For the full errors analysis experience, we recommend these capabilities:

* Enabling distributed tracing if you have it disabled. If you haven't disabled distributed tracing, it will be enabled by default.
* Integrating a log forwarder with New Relic to expand your logs in context experience

<Tabs>
	<TabsBar>
        <TabsBarItem id="1">
            Find the failure point with logs
        </TabsBarItem>
        <TabsBarItem id="2">
            Pinpoint errors in your code with stack traces
        </TabsBarItem>
    </TabsBar>

    <TabsPages>
        <TabsPageItem id="1">

    <Steps>
    <Step>
    ### Open the Log details window

Looking at our example, our log forwarder has sent full log details to New Relic. This allows us to read denser descriptions about the nature of our error:

    <img
        title="Overview errors affecting your services"
        alt="A screenshot showing an app with many errors"
        src={apmLogs}
    />

Our logs in context capability formats your logs information, though you have the option to investigate the unformatted log as well. 
    </Step>
    <Step>

    ### Read your logs
        
Depending on the nature of the log, you may have more or less logging detail to sort through. Because you spent time upfront narrowing down the service closest to the failure and choosing the likely error group, you have time to read your logs. 

<img
    title="Overview errors affecting your services"
    alt="A screenshot showing an app with many errors"
    src={apmLogsZoom}
    />    

According to your logs, your problem is:

* A timeout error: `error.error.code: ETIMEDOUT`
* Related to your customer API: `error.endpoint: customers-api-internal`
* Agnostic to the kind of request sent to the customer API: `error.request: /api/customers/search/Kirlin/-/`

</Step>
<Step>

### Find the failure point in your system

Having read your logs, you can now tie it all together. You conclude that there's a dependency failure: All calls to the customer API are timing out and causing upstream requests from `api-gateway` to fail. 

</Step>
</Steps>
</TabsPageItem>
<TabsPageItem id="2">

When you run your code, New Relic captures your exceptions or runtime errors and organizes them into a waterfall view. These are your stack traces. Depending on the language used, these stack traces provide detailed messages and additional context about failure points.  

    <img
    title="Overview errors affecting your services"
    alt="A screenshot showing an app with many errors"
    src={apmStackTraces}
    />    

Let's say you have hundreds of lines of code and something's mistyped somewhere. Reading that code from top to bottom wastes time and introduces more human error into the troubleshooting process. Stack traces tell you the exact location of that error.

For example:

1. You open your stack traces and see that an error is reporting at line 347.
2. Opening your IDE from the stack traces window, you see that line 347 references some login at line 100. 
3. You start reading your code from line 85, since you now know the rough snapshot of the error area.

Stack traces also give you identifying information about the nature of the error. The first stack trace reads: `File /usr/local/lib/python3.9/threading.py, line 937, in _boostrap`. 

1. You know that `threading.py` belongs to a critical part of your application.  
2. Other stack traces identify errors in `app.py`, but `app.py` is in a less critical part of your app. 
3. In that case, you know to find the sections of your code that correspond to `threading.py`. 

How you broach your stack traces is up to you, and depends largely on your familiarity with your app. 

</TabsPageItem>
</TabsPages>
</Tabs>

## What's next? [#next]

Reacting to an error and finding the direct cause of an outage is only part of dealing with errors in your app. Now that we've covered how to describe, diagnose, and find the source of an outage, we can move on to the other part of error management: proactively monitoring for errors.    

<UserJourneyControls
    nextStep={{path: "/docs/tutorial-error/analyze-your-errors", title: "Next step", body: "Direct cause versus root cause"}}
    previousStep={{path: "/docs/tutorial-errors/scope-the-problem", title: "Previous step", body: "Scope out the problem space"}}
/>