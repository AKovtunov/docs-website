---
title: Scope the problem
metaDescription: Learn how to monitor your system so you can quickly identify and resolve many error occurrences fast. 
---

import allEntitiesView from 'images/apm_screenshot-crop_all_entities.webp'

import apiGateway from 'images/apm_screenshot-crop_api-gateway-summary.webp'

import apmErrorsInboxPage from 'images/apm_screenshot-crop_errors-inbox-page.webp'

import apmErrorsAnomaly from 'images/apm_screenshot-crop_errors-anomaly.webp'

Working with highly complex, distributed systems inevitably leads to errors. Sometimes errors won't have a direct effect on customer experience, but in general errors often contribute to performance issues and outages. Understanding how to broach a high occurrence of errors can expedite the resolution and retrospective process, letting you improve your app and meet business goals. 

This tutorial series guides you through handling errors in your apps. As an observability platform, New Relic ingests a ton of data about your apps every day. You can define what “normal” is for your system, create alerts that notify you when things dip below (or above) normal, and, when the inevitable error happens, use all the data you’ve collected since instrumenting to grok at the problem. 

## Objectives [#objective]

This tutorial covers these concepts:

* Defining the problem
* Finding the source of an error 

## Define the problem [#problem]

When you're notified about an outage, you might encounter multiple kinds of errors. Limited by time, you need to quickly evaluate the scope of the problem and make a judgment call about where you'll start analysis. It's likely that the services that alerted you aren't actually the source of the problem, only indicators that one exists. 

We recommend you start with a problem statement with the end-user in mind. How the customer experiences an error is an integral part of determining a problem's urgency and priority. Think of it this way: if you have two services alerting -- one for logging in and one for searching inventory -- but only customers are only reporting that they can't search for a product, then you might want to start with the service that makes external API calls.

Here are some questions you might ask yourself when looking at your system: 

* What is the problem that the end-user is experiencing? 
* How should their experience look?
* What is the current behavior?

Let's put this in practice. The below screenshot displays all entities instrumented with New Relic. Four are alerting.

<img
title="Overview errors affecting your services"
alt="A screenshot showing an app with many errors"
src={allEntitiesView}
/>

Assuming you're familiar with your entire system, you don't need to rely on customer reports to understand how customers are experiencing a site. You know, though, that `api-gateway` is a dependency for other services that keep track of your inventory so customers can purchase only what's in stock. You can make an educated guess that:

* The problem the end-user is experiencing has to do with purchase actions.
* Your site should only display in-stock items so customers aren't ordering items that can't be delivered. 
* Customers are able to purchase out-of-stock items.

Understanding the nature of a problem is a small part of understanding why an outage occurred, but spending time to properly evaluate a problem will save you toil down the line. 

## Find the source [#source] 

Now that you've chosen an entry point into the problem, you can investigate the kinds of errors affecting your app. From the `apiGateway` summary page, you'll want to first look at the **Errors** tab, which filters your data to an errors-only view. 

<img
title="Overview errors affecting your services"
alt="A screenshot showing an app with many errors"
src={apmErrorsInboxPage}
/>

For this one service, you have at least six error groups reporting with anywhere from a dozen to thousands of occurrences in your app. Although daunting at first glance, you don't actually need to sort through every since error occurrence. New Relic has grouped individual occurrences of errors for you already, but how do you go about investigating the important errors? 

Start with the time series on the far right of the waterfall view. At first, this may not look like it's giving you any granular information, but what it is telling you is when an error occurred in time. We'll break this down:

* Based on number of occurrences alone, your first instinct might tell you to start with `ActivemModel:::ValidationError` as it has 4k occurrences. If you look at the time series, though, its peaks and troughs are relatively consistent. This could be an expected error, but let's look at the other five. 
* The `Net::OpenTimeOut` error group has a similar pattern, and it actually makes up four of the six reporting groups. Across each error group, you can see consistent peaks and troughs that extend before the incident. With the same name and similar patterns, we can infer this is an expected error and can eliminate all of them. This doesn't represent a change. 
* Our last option is `JsonapiClient:::Notfound`. Like `ActivemModel:::ValidationError`, it has a distinct shape and is consistently reporting. While it doesn’t have many occurrences, the timeseries is anomalous enough that might be worth digging a bit deeper. 

To choose which error to start with, you need to adjust the time parameter. This next screenshot extends the timeseries include behavior from the last 12 hours:

<img
title="Overview errors affecting your services"
alt="A screenshot showing an app with many errors"
src={apmErrorsAnomaly}
/>

With the adjustment, you can see that `ActivemModel:::ValidationError`has an unchanging pattern of peaks and troughs, but your  `JsonapiClient:::Notfound` has a dramatic change in behavior. This is a good ground zero. 

Knowing when something happened is a critical piece for getting closer to the source. Having a complete understanding of the problem space, we can now dig into the source. 

<UserJourneyControls
    nextStep={{path: "/docs/tutorial-errors/analyze-your-errors", title: "Next step", body: "Find what changed"}}
/>
