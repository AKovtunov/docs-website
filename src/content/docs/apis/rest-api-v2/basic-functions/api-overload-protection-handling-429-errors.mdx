---
title: 'API overload protection: Handling 429 errors'
tags:
  - APIs
  - REST API v2
  - GraphQL API
  - NerdGraph
  - Rate Limit
  - Concurrency Limit
  - Basic functions
translate:
  - kr
metaDescription: 'To prevent resource-intensive API calls from affecting other customers'' API calls, New Relic''s Graphql and REST APIs enforce usage limits.'
redirects:
  - /docs/apis/rest-api-v2/requirements/preventing-429-errors-api-overload-protection
  - /docs/apis/rest-api-v2/requirements/api-overload-protection-preventing-429-errors
  - /docs/apis/rest-api-v2/requirements/api-overload-protection-handling-429-errors
---

New Relic's GraphQL and REST APIs enforce usage limits to ensure the APIs remain stable and responsive for all customers even when under heavy load. Usage limits differ between the GraphQL API and the REST API.

## GraphQL API Usage Limits

New Relic's GraphQL API (NerdGraph) enforces a limit of **25 concurrent GraphQL requests per user**. NerdGraph does not limit the rate of requests you can make, only the number of _concurrent_ requests you make.

Concurrency is tracked and enforced per-user, _not_ per-API key. Requests made by the same user via multiple API keys will all contribute to a user's total concurrency.

NerdGraph _may_ allow more than 25 concurrent connections per user based on the state of the system, but **only 25 concurrent requests are guaranteed.**

Additional requests to the API that are made while you already have 25 concurrent requests in flight will be rejected with HTTP status code `429`. As your in-flight requests complete and your total concurrency drops, new requests will automatically begin to succeed again.

### How to avoid hitting the concurrency limit

If you are making concurrent requests to NerdGraph in your code it's important that you limit the total concurrency client-side. For example, if you need to make 100 requests you could:

 * Send the requests in batches of 25 concurrent calls.
 * Implement a pooling solution to ensure requests are only made when a concurrent connection is "available."
 * Replace concurrent code with sequential code and only make a request after the previous request has completed.

 Also be mindful of code that is run in multiple places at once. Even non-concurrent code will create concurrency if it's being run in multiple places.

## REST API Usage Limits

In order to respond quickly to your REST API calls—even when other customers are running time-consuming queries—New Relic includes overload protection in the API.

If you are querying a large enough amount of data to consume significant resources, the API's response code and headers will indicate that you have exceeded the capacity available for your API Key. This is a rare condition most customers will never see. Only customers whose API use is very resource-intensive will see it.

Customers will be limited to 1000 API calls per minute.

### API responses [#api_response]

Under normal operation, the API does not add any overload protection status to responses. You need not take any action.

Over the **reporting period** time interval, New Relic tracks each API request's impact on our system.

These are the typical cases that can trigger overload protection or rate limiting:

* An API key you're using has exceeded the maximum number of requests per minute.
* Our system is generally overloaded, and we need some accounts decrease their reporting.

In a case where rate limiting occurs, the following things will happen:

* Further API calls will fail with HTTP status code 429 (too many requests).
* The headers and body of the HTTP responses may or may not contain more information about the error.
* API calls will be allowed again at the end of the reporting period.

### Headers [#api_headers]

Here are the HTTP headers that will appear in API responses if you have exceeded your API key's individual limit:

<table>
  <thead>
    <tr>
      <th>
        Overload header
      </th>

      <th>
        Meaning
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `X-RateLimit-Limit`
      </td>

      <td>
        Maximum number of requests per minute.
      </td>
    </tr>

    <tr>
      <td>
        `X-RateLimit-Remaining`
      </td>

      <td>
        Number of requests remaining in this period.
      </td>
    </tr>

    <tr>
      <td>
        `X-RateLimit-Reset`
      </td>

      <td>
        UNIX timestamp (number of seconds since Jan. 1, 1970) when the current reporting period ends. API requests will be responded to after this time.
      </td>
    </tr>

    <tr>
      <td>
        `X-RateLimit-Docs`
      </td>

      <td>
        Hyperlink to this document so you immediately have additional information.
      </td>
    </tr>
  </tbody>
</table>

Here are the HTTP headers that will appear in API responses if there is a general system problem:

<table>
  <thead>
    <tr>
      <th style={{ width: "400px" }}>
        Overload header
      </th>

      <th>
        Meaning
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td id="overload-reset">
        `Retry-After`
      </td>

      <td>
        Number of seconds until you should try again.
      </td>
    </tr>
  </tbody>
</table>

### Example [#api_example]

Here is an example API request indicating that the caller has consumed all of the available resources, and that further API calls will be allowed again at noon on Feb. 1, 2016:

```
curl -X GET 'https://api.newrelic.com/v2/applications.json' \
     -H "Api-Key:<a href='/docs/apis/rest-api-v2/getting-started/introduction-new-relic-rest-api-v2#api_key'>$API_KEY</a>" -i
HTTP/1.1 429 Too Many Requests
Content-Type: application/json
...
X-RateLimit-Docs: https://docs.newrelic.com/docs/apis/rest-api-v2/requirements/api-overload-protection-preventing-429-errors
X-RateLimit-Reset: 1454313600
X-RateLimit-Remaining: 0
X-RateLimit-Limit: 1000

{}
```

### Preventing rate limiting errors [#preventing-errors]

The simplest remedy for a 429 error is to wait until the reporting period ends before sending your next API request. However, with careful management of your queries, you can avoid overload protection errors in the first place.

If you know you will be sending many resource-intensive queries, you can perform one of the following preventative measures:

* Send your queries less often; in particular, query less frequently than once per minute (the refresh rate for agent data).
* Cache data from New Relic rather than requesting it from the API every time.
* Use the [cursor-based technique](/docs/apis/rest-api-v2/requirements/pagination-api-output#metric_name_cursor_paging) if you must request metric names and the output results in multiple pages.
