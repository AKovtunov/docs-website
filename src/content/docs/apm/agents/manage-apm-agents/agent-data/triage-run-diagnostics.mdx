---
title: Get started triaging with APM
tags:
  - APM
  - Triage
  - Diagnostics
metaDescription: Use our application monitoring tools to quickly triage and run diagnostics during an incident.
---

We all know what it's like to wake up in the morning to a ping from your leadership team telling you that something is going wrong and they need it fixed as soon as possible. This is where our <InlinePopover type="apm" /> tools come in. When you have limited time and increased urgency, you can use the APM summary page to to find failures in your applications and triage issues from one place.

The APM summary page is an overview of the important metrics for your service. It's the first place you will go to investigate the source of a service degradation. On the APM summary page you can check the health of your service, understand any problems within a larger context, and take the necessary steps to resolve the issue. 

This do walks you through how to use New Relic's APM tools to triage issues. We're going to explore a situation where you work for an e-commerce company and you manage the checkout team.  Customers have been complaining they have to wait too long to checkout. To investigate, open APM and select your `Checkout-service`.


<Steps>
<Step>

## First, review these key metrics
Is there a problem with your `Checkout-service`? Which systems are affected and how?

<CollapserGroup>
  <Collapser
    id="apdex"
    title="Apdex"
  >

The first place to look when investigating a breakdown in service is your Apdex score. Your Apdex score monitors overall customer satisfaction with your application. Your score looks for a combination of performance, like response time or throughput, and error rates. 

Apdex is an industry standard that measures your users' satisfaction with the response time of your web application/service. It's represented as a score from 0-1. The closer your score is to 1, the better your app is performing. The default value for a satisfactory experience is 0.5 seconds, but you can set a different target under Settings.

Your Apdex score is typically divided in the following colors:

* ** &lt; 0.5 - Gray:** Your application's performance is beyond critical and needs immediate action.
* **0.5-0.7 - Red:** There are critical performance issues in your application and it needs immediate action. 
* **0.7-0.85 -Orange:** Your application is trending in a negative direction and needs further investigation. 
* **0.85-0.95 - Blue:** This is the ideal Apdex range. This score means that you have fine-tuned your Your Apdex T perfectly for your application and your performance is healthy. 
* **&gt; 0.95 - Blue:** If your Apdex score is this high it means that your Apdex T might be set a little too high and you're not getting an accurate read on your application's performance.. You should consider reducing your Apdex T.


<Callout variant="tip">
If you have an Apdex score of 0 that could be because a request returned with an error. Every request with an error automatically scores a 0 on Apdex. 
</Callout>

While investigating the breakdown of your `Pay Now` button, you see that your Apdex score has fallen and is hovering closer to 0. The chart is red. You now know for certain that your customers complaints are correct: there is a problem somewhere in your stack. 


</Collapser>

  <Collapser
    id="web-transactions"
    title="Web transactions"
  >

Based on customer reports you know that checkout is failing in your app but you're unsure of what's causing the actual error. You've checked Apdex and it's showing poor user satisfaction. The next step is to figure out what part of the checkout process is breaking and investigate your app's `Web-transactions`.  

At New Relic, a transaction is defined as one logical unit of work in a software application. Specifically, it refers to the function calls and method calls that make up that unit of work. For APM, it will often refer to a web transaction, which represents activity that happens from when the application receives a web request to when the response is sent. 

Web transaction time is broken up into three parts. 

* The blue segment signifies all transactions. 
* The yellow segment represents your databases. 
* The green segment displays your external servers.  

<Callout variant="tip">
If you're trying to monitor an asynchronous application then your response time - the dark blue line - could possibly be lower than the response times for each individual segment (transactions, databases, and externals). This could happen because an asynchronous application can process multiple requests at the same time. So, it is possible for a  transaction to “end” while some requests are still “open”. 
</Callout>

A slow transaction can be a strong indicator that something is behaving abnormally, so take a look at the chart and see if any areas of your service are taking longer than normal to respond. Slow transactions will look like spikes on the chart. 
</Collapser>


  <Collapser
    id="throughput"
    title="Throughput"
  >

While looking at response time for this transaction, you can also investigate throughput. Throughput is a way to measure the amount of work your application is handling. Throughput is a way to measure the amount of work your application is handling. Throughput helps you understand if work is evenly distributed between your hosts and containers. Performance issues can often be a symptom of lack of resources.

For the purposes of this example, you see that throughput is a little higher than usual. If your throughput is very high during a time of service degradation, it could indicate that your application is processing more work than it can handle. Knowing this we may look at slow traces which may indicate if it's a code problem or Infrastructure telemetry may help surface if it's a resource issue. 

On the other hand, low throughput could indicate that your app isn't handling very many requests. This could simply mean that it's not used very much or it could mean that a service upstream that calls to your application is broken and requests aren't being processed.
</Collapser>

  <Collapser
    id="errors"
    title="Errors"
  >

Now that you've identified slow transactions and analyzed your throughput, it's time to take a look at errors. The errors chart shows you the percentage of transactions that resulted in an error. An error is an event. APM Errors specifically look for `TransactionError` and `ErrorTrace` events.

In this case you see a spike in `Web errors` around the same time that your web transaction response time spiked. You can also use our [deployment marker tool](/docs/apm/apm-ui-pages/events/record-deployments/) to see that your team released a change around the time that customers began to complain that the `Pay Now` button was taking a long time to load. 

A deployment marker shows up as a gray pin on the each chart. You can hover over the pin for overview information or you can click the marker for a deeper look into the deployment.

For more about how to manage errors, see [Manage errors]](/docs/apm/agents/manage-apm-agents/agent-data/manage-errors-apm-collect-ignore-or-mark-expected/)

</Collapser>
</CollapserGroup>

</Step>

<Step>
## Locate the problem in a larger context
Which parts of your stack are in trouble? Is there a problem upstream or downstream? 

<CollapserGroup>
  <Collapser
    id="logs"
    title="Logs"
  >

The logs chart gives you a summary view of your application logs reported through our [logs in context](docs/logs/logs-context/get-started-logs-context/) feature. Clicking **Logs** takes you to the full [Logs UI](/docs/logs/ui-data/use-logs-ui/)

After investigating your key metrics, you know you have a problem with a recent deployment that affected `Web-transaction` time which resulted in a spike in errors, and low user satisfaction. Now you want to know how this affected the rest of your service. 

With logs in context, your individual logs are tagged with the entity or service they're related to. On the logs chart you can select **Log patterns (top 10)** to display groups of logs that are identical up to the unique string identifiers. 

For more about how log patterns work, see [Log patterns](/docs/logs/ui-data/find-unusual-logs-log-patterns/).

</Collapser>

  <Collapser
    id="distributed-tracing"
    title="Distributed tracing"
  >

You can use the **Distributed Tracing** chart to learn more about whether your slow response times and high error rates are because of changes either upstream or downstream.  Let's say you want to dig deeper into your slow response times, you will click into that section and you will see a list of traces that either go through your entire service  or touch other areas of your ecosystem. New Relic will display areas where these other places are _also_ having increase in response times. 

You can learn more in our [Distributed tracing docs](/docs/distributed-tracing/concepts/introduction-distributed-tracing/).
</Collapser>

  <Collapser
    id="infrastructure"
    title="Infrastructure"
  >

Now, scroll down to the Infrastructure section of the APM summary page. Here you'll see a table that lists each host connected to the  `Checkout Service` application and a record of their Response time, Throughput, Error rate, CPU%. and Memory %. 

Learn more about how to investiage infrastructure data on the APM summary page [here](/docs/infrastructure/manage-your-data/data-instrumentation/apm-data-infrastructure-monitoring/).

</Collapser>
</CollapserGroup>


</Step>

<Step>

## Dig deeper into the transaction details 

Okay, so you know that your response times are down, your error rates are up based on a recent deployment. You've investigated CPU% and memory with infrastructure, you've identified trends with logs, and you know what else has been affected upstream and downstream in your stack. 

Now, it's time to look a little harder at the problematic transactions. 

<CollapserGroup>

  <Collapser
    id="slowest-transactions"
    title="Investigate your slowest transaction"
  >

Click **Transactions**.  You will see a list of all the "work" that is happening behind the scenes in your `Checkout-service` application. On the left-hand side you will see which transaction is taking the most time. 

For the purpose of this example, the slowest transaction is Sinatra/Rubytron/POST #purchaseCart. Click on the transaction.

Now we've identified the slowest transaction `Sinatra/Rubytron/POST #purchaseCart` for the `Checkout-service` application and we want to learn more about how it's working. 

Each transaction is comprised of many different units of "work." For example, for the `Sinatra/Rubytron/POST #purchaseCart` transaction a unit of work could be validating the input, performing business logic, or updating a database.

The **Transactions detail** page provides a holistic view of a single transaction by breaking it down into individual pieces of work. The histogram on top visually demonstrates which pieces of the transaction are responding slower than others. 

We want to figure out where the `Sinatra/Rubytron/POST #purchaseCart` transaction could be failing: databases, servers, controllers, or middleware. You can toggle between each different segment of the transaction to identify trends and spikes.

</Collapser>

  <Collapser
    id="transaction-breakdown"
    title="Transaction breakdown"
  >

The transaction breakdown refers to the detailed breakdown of the time spent on each operation within a specific transaction. This breakdown helps developers understand the general performance of the transaction and identify bottlenecks or areas for improvement.

You can sort the transaction breakdown by **Category**, **% Time**, **Avg Calls/Txn**, and **Avg Time**. We recommend sorting by **% Time** to understand which piece of the transaction is taking up the most time within each transaction. 

Let's examine the sections of the **Breakdown table**:

* **Category** refers to the type of call segment being monitored. 
* **Controller** is a type of **category** that refers to model-view-controller architecture and is most likely a call made directly from your UI to your application. 
* **External** is a type of **category** that represents a call being made that we began monitoring before we know where it's going.  
* **Middleware** is a type of **category** that most often refers to a dependency or library that is being used as part of your application's functionality. 
* **Segment** consists of the name of the function and call segment being monitored.
* **% Time** refers to the percentage of time each specific segment takes of the total transaction lifecycle. It's important to remember that some segments wait until all the other segments are completed before they're completed. I
* **Avg Calls/Txn** is the amount of times that the segment is called per transaction during the time selected using the time picker. 
* **Avg Time** is the average time that a particular segment took to complete. It's important to keep in mind that there could be asynchronous work happening. One segment could be ongoing and then other, nested work, is being done at the same time. 

Once you sort the **Breakdown table**, you can click on any problematic segments. 

To learn more about the Transactions page, see [Transactions page](/docs/apm/apm-ui-pages/monitoring/transactions-page-find-specific-performance-problems/)
</Collapser>

  <Collapser
    id="transaction-traces"
    title="Transaction traces"
>

When your customers are trying to purchase something on your site and they use the `Pay Now` button, the `Checkout-service` application generates multiple database queries, API calls, and other interactions with the underlying infrastructure. 

Transaction traces keep a record of every interaction between `Checkout-service` and your customers. 

The Trace waterfall view shows you how the processing of this request unfolded in your code. Which aspects took the longest, so it's easy to identify where your bottleneck may be to know which functions, database call or HTTP call may be degrading the performance of your application. Now you have all the information you need to fix the Pay Now button for your application.

To learn more about transaction traces, see [Transaction Traces](/docs/apm/transactions/transaction-traces/introduction-transaction-traces/).

</Collapser>
</CollapserGroup>


</Step>
<Step>
##You're done investigating

    And now you have all the information you need to fix the `Pay Now` button for your application. 

* You know which transaction is causing the service degradation of `Checkout-service`: `Sinatra/Rubytron/POST #purchaseCart`.
* You know when the problem started.
* You know which piece of the transaction is causing the breakdown in service: `Sinatra/Rubytron/POST`.

Your team can now start fixing the origin of the problem and get your checkout up-and-running as quickly as possible. 

</Step>
</Steps>

